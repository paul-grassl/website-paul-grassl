---
import Layout from "@/layouts/Layout.astro";
import Header from "@/components/Header.astro";
import Footer from "@/components/Footer.astro";
import { getCollection } from "astro:content";
import { Image } from "astro:assets";

export async function getStaticPaths() {
  const allWorks = await getCollection("works");
  const years = [...new Set(allWorks.map(work => work.data.year))];
  
  return years.map(year => ({
    params: { year: year.toString() },
    props: { 
      year,
      works: allWorks
        .filter(work => work.data.year === year)
        .sort((a, b) => (a.data.order || 0) - (b.data.order || 0))
    },
  }));
}

const { year, works } = Astro.props;
const title = `Works ${year}`;
const description = `Artwork by Paul Graßl from ${year}`;
---

<Layout title={title} description={description}>
  <Header />
  <main id="main-content">
    <section class="mx-auto w-full max-w-5xl px-6 py-8">
      <div class="flex flex-col gap-y-8">
        <div class="w-full">
          <h1 class="text-2xl font-normal leading-tight mb-2 text-foreground">Works {year}</h1>
        </div>

        {works.map((work) => (
          <div class="w-full">
            {work.data.isSeries ? (
              <!-- Series slideshow -->
              <div class="work-series" data-work-title={work.data.title} data-technique={work.data.technique} data-size={work.data.size} data-slide-count={work.data.images?.length || 0}>
                <div class="slideshow-container relative">
                  <div class="slides">
                    {work.data.images?.map((image, index) => (
                      <div class={`slide ${index === 0 ? 'active' : 'hidden'}`} data-slide-index={index}>
                        <div class={`${image.orientation === 'portrait' ? 'flex justify-center' : 'flex justify-center'}`}>
                          <div class={`relative ${
                            work.data.displaySize === 'small' 
                              ? (image.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg') 
                              : work.data.displaySize === 'large'
                              ? (image.orientation === 'portrait' ? 'max-w-xl' : 'max-w-4xl')
                              : (image.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                          } mx-auto`}>
                            <Image
                              src={image.src}
                              alt={`${work.data.title} - ${image.specificTitle || `Work ${index + 1}`}`}
                              class="w-full"
                              width={image.orientation === 'portrait' ? 600 : 1920}
                              height={image.orientation === 'portrait' ? 900 : 1280}
                              quality={80}
                              format="webp"
                              densities={[1, 2]}
                              loading={index <= 1 ? "eager" : "lazy"}
                            />
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                  
                  <!-- Mobile navigation areas - contained within image -->
                  <div class="absolute inset-0 flex z-10 md:hidden">
                    <div class="w-1/2 h-full slide-nav-left cursor-pointer" data-direction="prev"></div>
                    <div class="w-1/2 h-full slide-nav-right cursor-pointer" data-direction="next"></div>
                  </div>
                  
                  <!-- Desktop navigation areas - extending beyond image -->
                  <div class="absolute inset-x-0 inset-y-0 hidden md:flex z-10" style="left: -50vw; right: -50vw;">
                    <div class="w-1/2 h-full slide-nav-left cursor-pointer" data-direction="prev"></div>
                    <div class="w-1/2 h-full slide-nav-right cursor-pointer" data-direction="next"></div>
                  </div>
                  
                  <!-- Navigation arrows - hidden on mobile -->
                  <div class="nav-arrow nav-arrow-left fixed left-4 top-1/2 transform -translate-y-1/2 opacity-0 transition-opacity duration-200 z-20 pointer-events-none hidden md:block">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="text-gray-600">
                      <path d="M15 18L9 12L15 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                  </div>
                  <div class="nav-arrow nav-arrow-right fixed right-4 top-1/2 transform -translate-y-1/2 opacity-0 transition-opacity duration-200 z-20 pointer-events-none hidden md:block">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" class="text-gray-600">
                      <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                  </div>
                  

                </div>
                
                <!-- Series text information -->
                <div class="mt-2">
                  <!-- Container for both left counter and center individual info -->
                  <div class={`${
                      work.data.displaySize === 'small' 
                        ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg')
                        : work.data.displaySize === 'large'
                        ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xl' : 'max-w-3xl')
                        : (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                    } mx-auto flex justify-between items-start`}>
                      <!-- Left side: Order counter -->
                      <div class="slide-counter w-16">
                        {work.data.images?.map((image, index) => (
                          <div class={`counter-item ${index === 0 ? 'block' : 'hidden'} text-base text-gray-500`} data-slide-index={index}>
                            {index + 1}/{work.data.images?.length || 0}
                          </div>
                        ))}
                      </div>
                      
                      <!-- Center: Specific work info -->
                      <div class="specific-info text-center flex-1">
                        {work.data.images?.map((image, index) => (
                          <div class={`specific-title ${index === 0 ? 'block' : 'hidden'}`} data-slide-index={index}>
                            <span class="text-base italic text-foreground">
                              {image.specificTitle || `Work ${index + 1}`}
                            </span>
                          </div>
                        ))}
                      </div>
                      
                      <!-- Right side: Mobile swipe indicator -->
                      <div class="w-16 flex justify-end">
                        <div class="swipe-indicator md:hidden text-gray-500 text-base" aria-hidden="true">
                          →
                        </div>
                      </div>
                  </div>
                  
                  <!-- General work info -->
                  <div class={`general-info mt-3`}>
                    <div class={`${
                        work.data.displaySize === 'small' 
                          ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg')
                          : work.data.displaySize === 'large'
                          ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xl' : 'max-w-3xl')
                          : (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                      } mx-auto text-center`}>
                        <h3 class="text-base italic font-normal leading-tight text-foreground">{work.data.title}</h3>
                        <div class="mt-0.5 flex flex-col gap-y-0.5 text-base text-muted-foreground">
                          <span>{work.data.technique}</span>
                          <span>{work.data.size}</span>
                        </div>
                      </div>
                  </div>
                </div>
              </div>
            ) : (
              <!-- Single work -->
              <div class="single-work">
                <div class={`${work.data.orientation === 'portrait' ? 'flex justify-center' : 'flex justify-center'}`}>
                  <div class={`relative ${
                    work.data.displaySize === 'small' 
                      ? (work.data.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg') 
                      : work.data.displaySize === 'large'
                      ? (work.data.orientation === 'portrait' ? 'max-w-xl' : 'max-w-4xl')
                      : (work.data.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                  } mx-auto`}>
                    <Image
                      src={work.data.image!}
                      alt={work.data.title}
                      class="w-full"
                      width={work.data.orientation === 'portrait' ? 600 : 1920}
                      height={work.data.orientation === 'portrait' ? 900 : 1280}
                      quality={80}
                      format="webp"
                      densities={[1, 2]}
                      loading="lazy"
                    />
                  </div>
                </div>
                
                <!-- Single work text information -->
                <div class={`mt-2 text-center ${
                  work.data.displaySize === 'small' 
                    ? (work.data.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg') 
                    : work.data.displaySize === 'large'
                    ? (work.data.orientation === 'portrait' ? 'max-w-xl' : 'max-w-4xl')
                    : (work.data.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                } mx-auto`}>
                  <h3 class="text-base italic font-normal leading-tight text-foreground">{work.data.title}</h3>
                  <div class="mt-0.5 flex flex-col gap-y-0.5 text-base text-muted-foreground">
                    <span>{work.data.technique}</span>
                    <span>{work.data.size}</span>
                  </div>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </section>
  </main>
  <Footer />
</Layout>

<script>
  // Slideshow functionality
  function initSlideshows() {
    const seriesContainers = document.querySelectorAll('.work-series');
    
    if (seriesContainers.length === 0) {
      // No series containers found, try again after a short delay
      setTimeout(initSlideshows, 100);
      return;
    }
    
    seriesContainers.forEach(container => {
      // Skip if already initialized
      if (container.hasAttribute('data-slideshow-initialized')) {
        return;
      }
      
      const slides = container.querySelectorAll('.slide');
      const specificTitles = container.querySelectorAll('.specific-title');
      const counterItems = container.querySelectorAll('.counter-item');
      const leftArrow = document.querySelector('.nav-arrow-left');
      const rightArrow = document.querySelector('.nav-arrow-right');
      
      // Only proceed if we have slides
      if (slides.length === 0) {
        return;
      }
      
      let currentSlide = 0;
      let isTransitioning = false;
      
      function showSlide(index: number) {
        // Preserve scroll position more reliably
        const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
        
        // Prevent any automatic scrolling
        document.body.style.overflowAnchor = 'none';
        
        // Hide all slides, titles, and counters
        slides.forEach(slide => {
          slide.classList.add('hidden');
          slide.classList.remove('active');
        });
        specificTitles.forEach(title => {
          title.classList.add('hidden');
          title.classList.remove('block');
        });
        counterItems.forEach(counter => {
          counter.classList.add('hidden');
          counter.classList.remove('block');
        });
        
        // Show current slide, title, and counter
        if (slides[index]) {
          slides[index].classList.remove('hidden');
          slides[index].classList.add('active');
        }
        if (specificTitles[index]) {
          specificTitles[index].classList.remove('hidden');
          specificTitles[index].classList.add('block');
        }
        if (counterItems[index]) {
          counterItems[index].classList.remove('hidden');
          counterItems[index].classList.add('block');
        }
        
        // Use requestAnimationFrame to ensure DOM is updated before restoring scroll
        requestAnimationFrame(() => {
          window.scrollTo(0, currentScroll);
          // Re-enable scroll anchoring after a brief delay
          setTimeout(() => {
            document.body.style.overflowAnchor = 'auto';
          }, 100);
        });
      }
      
      function nextSlide() {
        if (isTransitioning) return;
        isTransitioning = true;
        
        // Prevent focus changes from causing scroll jumps
        const activeElement = document.activeElement as HTMLElement;
        currentSlide = (currentSlide + 1) % slides.length;
        showSlide(currentSlide);
        // Keep focus on the same element to prevent scroll jumps
        if (activeElement) {
          activeElement.blur();
        }
        
        setTimeout(() => {
          isTransitioning = false;
        }, 300);
      }
      
      function prevSlide() {
        if (isTransitioning) return;
        isTransitioning = true;
        
        // Prevent focus changes from causing scroll jumps
        const activeElement = document.activeElement as HTMLElement;
        currentSlide = (currentSlide - 1 + slides.length) % slides.length;
        showSlide(currentSlide);
        // Keep focus on the same element to prevent scroll jumps
        if (activeElement) {
          activeElement.blur();
        }
        
        setTimeout(() => {
          isTransitioning = false;
        }, 300);
      }
      
      // Touch/Swipe support variables
      let startX = 0;
      let startY = 0;
      let endX = 0;
      let endY = 0;
      const minSwipeDistance = 50;
      
      // Handle swipe gestures
      function handleSwipe() {
        try {
          const deltaX = endX - startX;
          const deltaY = endY - startY;
          
          // Check if horizontal swipe is dominant and meets minimum distance
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
            if (deltaX > 0) {
              // Swipe right -> previous slide
              prevSlide();
            } else {
              // Swipe left -> next slide
              nextSlide();
            }
          }
        } catch (error) {
          console.error('Swipe handling error:', error);
        }
      }

      // Add click and touch handlers for navigation
      const containerNavElements = container.querySelectorAll('.slide-nav-left, .slide-nav-right');
      containerNavElements.forEach(nav => {
        // Click handlers
        nav.addEventListener('click', (e) => {
          try {
            e.preventDefault();
            e.stopPropagation();
            const direction = nav.getAttribute('data-direction');
            if (direction === 'next') {
              nextSlide();
            } else if (direction === 'prev') {
              prevSlide();
            }
          } catch (error) {
            console.error('Click handler error:', error);
          }
        });
        
        // Touch handlers for swipe
        nav.addEventListener('touchstart', (e) => {
          try {
            const touchEvent = e as TouchEvent;
            startX = touchEvent.touches[0].clientX;
            startY = touchEvent.touches[0].clientY;
          } catch (error) {
            console.error('Touch start error:', error);
          }
        }, { passive: true });
        
        nav.addEventListener('touchend', (e) => {
          try {
            const touchEvent = e as TouchEvent;
            endX = touchEvent.changedTouches[0].clientX;
            endY = touchEvent.changedTouches[0].clientY;
            handleSwipe();
          } catch (error) {
            console.error('Touch end error:', error);
          }
        }, { passive: true });
        
        // Add hover handlers for arrows (desktop only)
        nav.addEventListener('mouseenter', () => {
          try {
            const direction = nav.getAttribute('data-direction');
            if (direction === 'next' && rightArrow) {
              (rightArrow as HTMLElement).style.opacity = '1';
            } else if (direction === 'prev' && leftArrow) {
              (leftArrow as HTMLElement).style.opacity = '1';
            }
          } catch (error) {
            console.error('Mouse enter error:', error);
          }
        });
        
        nav.addEventListener('mouseleave', () => {
          try {
            if (leftArrow) (leftArrow as HTMLElement).style.opacity = '0';
            if (rightArrow) (rightArrow as HTMLElement).style.opacity = '0';
          } catch (error) {
            console.error('Mouse leave error:', error);
          }
        });
        
        // Keyboard navigation
        nav.setAttribute('tabindex', '0');
        nav.setAttribute('role', 'button');
        nav.setAttribute('aria-label', nav.getAttribute('data-direction') === 'next' ? 'Nächstes Bild' : 'Vorheriges Bild');
        
        nav.addEventListener('keydown', (e) => {
          try {
            const keyboardEvent = e as KeyboardEvent;
            if (keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ') {
              e.preventDefault();
              const direction = nav.getAttribute('data-direction');
              if (direction === 'next') {
                nextSlide();
              } else if (direction === 'prev') {
                prevSlide();
              }
            }
          } catch (error) {
            console.error('Keyboard navigation error:', error);
          }
        });
      });
      
      // Mark as initialized
      container.setAttribute('data-slideshow-initialized', 'true');
    });
  }
  
  // Robust initialization function that handles multiple scenarios
  function safeInitSlideshows() {
    // Try immediate initialization
    initSlideshows();
    
    // Also try after images are loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSlideshows);
    }
    
    // And after window load (all resources including images)
    if (document.readyState !== 'complete') {
      window.addEventListener('load', initSlideshows);
    }
    
    // Preserve scroll position on load
    const scrollY = window.scrollY;
    setTimeout(() => {
      window.scrollTo(0, scrollY);
    }, 0);
  }

  // Initialize based on current document state
  if (document.readyState === 'loading') {
    // Document is still loading
    document.addEventListener('DOMContentLoaded', safeInitSlideshows);
  } else {
    // Document is already loaded
    safeInitSlideshows();
  }
  
  // Re-initialize on view transitions (Astro navigation)
  document.addEventListener('astro:after-swap', () => {
    // Clear any existing initialization markers
    document.querySelectorAll('[data-slideshow-initialized]').forEach(el => {
      el.removeAttribute('data-slideshow-initialized');
    });
    
    // Preserve scroll position on navigation
    const scrollY = window.scrollY;
    safeInitSlideshows();
    setTimeout(() => {
      window.scrollTo(0, scrollY);
    }, 0);
  });
  
  // Also listen for astro:page-load (triggered on direct page loads)
  document.addEventListener('astro:page-load', () => {
    safeInitSlideshows();
  });
</script>

<style>
  .slide {
    position: relative;
  }
  
  .specific-title,
  .counter-item {
    transition: opacity 0.2s ease-in-out;
  }
  
  .nav-arrow {
    background: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    padding: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }
  
  .slide-nav-left,
  .slide-nav-right {
    transition: opacity 0.2s ease-in-out;
  }
  
  .slideshow-container {
    overflow: hidden;
  }
  
  /* Prevent horizontal scroll on mobile */
  @media (max-width: 768px) {
    body {
      overflow-x: hidden;
    }
    
    .work-series {
      overflow: hidden;
    }
  }
  
  /* Prevent scroll jumping during slide transitions */
  .work-series {
    overflow-anchor: none;
  }
  
  .work-series .slide {
    overflow-anchor: none;
  }
  
  .work-series .slideshow-container {
    overflow-anchor: none;
  }
  
  /* Mobile swipe indicator */
  .swipe-indicator {
    opacity: 0.7;
    font-size: 1.2rem;
    line-height: 1;
    user-select: none;
    pointer-events: none;
  }
  
  /* Hide indicator for single-slide series */
  .work-series[data-slide-count="1"] .swipe-indicator {
    display: none;
  }
</style>
