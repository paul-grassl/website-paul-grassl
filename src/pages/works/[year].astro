---
import Layout from "@/layouts/Layout.astro";
import Header from "@/components/Header.astro";
import Footer from "@/components/Footer.astro";
import { getCollection } from "astro:content";
import { Image } from "astro:assets";

export async function getStaticPaths() {
  const allWorks = await getCollection("works");
  const years = [...new Set(allWorks.map(work => work.data.year))];
  
  return years.map(year => ({
    params: { year: year.toString() },
    props: { 
      year,
      works: allWorks
        .filter(work => work.data.year === year)
        .sort((a, b) => (a.data.order || 0) - (b.data.order || 0))
    },
  }));
}

const { year, works } = Astro.props;
const title = `Works ${year}`;
const description = `Artwork by Paul Graßl from ${year}`;
---

<Layout title={title} description={description}>
  <Header />
  <main id="main-content">
    <section class="mx-auto w-full max-w-5xl px-6 py-8">
      <div class="flex flex-col gap-y-8">
        <div class="w-full">
          <h1 class="text-2xl font-normal leading-tight mb-2 text-foreground">Works {year}</h1>
        </div>

        {works.map((work) => (
          <div class="w-full">
            {work.data.isSeries ? (
              <!-- Series slideshow -->
              <div class="work-series" data-work-title={work.data.title} data-technique={work.data.technique} data-size={work.data.size} data-slide-count={work.data.images?.length || 0}>
                <div class="slideshow-container relative">
                  <div class="slides">
                    {work.data.images?.map((image, index) => (
                      <div class={`slide ${index === 0 ? 'active' : 'hidden'}`} data-slide-index={index}>
                        <div class={`${image.orientation === 'portrait' ? 'flex justify-center' : 'flex justify-center'}`}>
                          <div class={`image-container relative cursor-pointer ${
                            work.data.displaySize === 'small' 
                              ? (image.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg') 
                              : work.data.displaySize === 'large'
                              ? (image.orientation === 'portrait' ? 'max-w-xl' : 'max-w-4xl')
                              : (image.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                          } mx-auto`}>
                            <Image
                              src={image.src}
                              alt={`${work.data.title} - ${image.specificTitle || `Work ${index + 1}`}`}
                              class="w-full"
                              width={image.orientation === 'portrait' ? 600 : 1920}
                              height={image.orientation === 'portrait' ? 900 : 1280}
                              quality={80}
                              format="webp"
                              densities={[1, 2]}
                              loading={index < 3 ? "eager" : "lazy"}
                            />
                          </div>
                        </div>
                      </div>
                    ))}
                  </div>
                  

                </div>
                
                <!-- Series text information -->
                <div class="mt-2">
                  <!-- Container for both left counter and center individual info -->
                  <div class={`${
                      work.data.displaySize === 'small' 
                        ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg')
                        : work.data.displaySize === 'large'
                        ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xl' : 'max-w-3xl')
                        : (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                    } mx-auto`}>
                      
                      <!-- Center: Specific work info with navigation arrows -->
                      <div class="specific-info text-center flex items-center justify-center gap-x-4">
                        <button type="button" class="title-arrow slide-nav-left" aria-label="Vorheriges Bild" data-direction="prev">←</button>
                        <div class="flex-1">
                          {work.data.images?.map((image, index) => (
                            <div class={`specific-title ${index === 0 ? 'block' : 'hidden'}`} data-slide-index={index}>
                              <span class="text-base italic text-foreground">
                                {image.specificTitle || `Work ${index + 1}`}
                              </span>
                            </div>
                          ))}
                        </div>
                        <button type="button" class="title-arrow slide-nav-right" aria-label="Nächstes Bild" data-direction="next">→</button>
                      </div>
                      
                  </div>
                  
                  <!-- General work info -->
                  <div class={`general-info mt-3`}>
                    <div class={`${
                        work.data.displaySize === 'small' 
                          ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg')
                          : work.data.displaySize === 'large'
                          ? (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-xl' : 'max-w-3xl')
                          : (work.data.images?.[0]?.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                      } mx-auto text-center`}>
                        <h3 class="text-base italic font-normal leading-tight text-foreground">{work.data.title}</h3>
                        <div class="mt-0.5 flex flex-col gap-y-0.5 text-base text-muted-foreground">
                          <span>{work.data.technique}</span>
                          <span>{work.data.size}</span>
                        </div>
                      </div>
                  </div>
                </div>
              </div>
            ) : (
              <!-- Single work -->
              <div class="single-work">
                <div class={`${work.data.orientation === 'portrait' ? 'flex justify-center' : 'flex justify-center'}`}>
                  <div class={`relative ${
                    work.data.displaySize === 'small' 
                      ? (work.data.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg') 
                      : work.data.displaySize === 'large'
                      ? (work.data.orientation === 'portrait' ? 'max-w-xl' : 'max-w-4xl')
                      : (work.data.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                  } mx-auto`}>
                    <Image
                      src={work.data.image!}
                      alt={work.data.title}
                      class="w-full"
                      width={work.data.orientation === 'portrait' ? 600 : 1920}
                      height={work.data.orientation === 'portrait' ? 900 : 1280}
                      quality={80}
                      format="webp"
                      densities={[1, 2]}
                      loading="lazy"
                    />
                  </div>
                </div>
                
                <!-- Single work text information -->
                <div class={`mt-2 text-center ${
                  work.data.displaySize === 'small' 
                    ? (work.data.orientation === 'portrait' ? 'max-w-xs' : 'max-w-lg') 
                    : work.data.displaySize === 'large'
                    ? (work.data.orientation === 'portrait' ? 'max-w-xl' : 'max-w-4xl')
                    : (work.data.orientation === 'portrait' ? 'max-w-lg' : 'max-w-2xl')
                } mx-auto`}>
                  <h3 class="text-base italic font-normal leading-tight text-foreground">{work.data.title}</h3>
                  <div class="mt-0.5 flex flex-col gap-y-0.5 text-base text-muted-foreground">
                    <span>{work.data.technique}</span>
                    <span>{work.data.size}</span>
                  </div>
                </div>
              </div>
            )}
          </div>
        ))}
      </div>
    </section>
  </main>
  <Footer />
</Layout>

<script>
  // Slideshow functionality
  function initSlideshows() {
    const seriesContainers = document.querySelectorAll('.work-series');
    
    if (seriesContainers.length === 0) {
      // No series containers found, try again after a short delay
      setTimeout(initSlideshows, 100);
      return;
    }
    
    seriesContainers.forEach(container => {
      // Skip if already initialized
      if (container.hasAttribute('data-slideshow-initialized')) {
        return;
      }
      
      const slides = container.querySelectorAll('.slide');
      const specificTitles = container.querySelectorAll('.specific-title');
      
      // Only proceed if we have slides
      if (slides.length === 0) {
        return;
      }
      
      let currentSlide = 0;
      let isTransitioning = false;
      let hasPreloaded = false;
      
      // Preload remaining images (index >= 3)
      function preloadRemainingImages() {
        if (hasPreloaded) return;
        hasPreloaded = true;
        
        slides.forEach((slide, index) => {
          if (index >= 3) {
            const img = slide.querySelector('img');
            if (img && img.loading === 'lazy') {
              img.loading = 'eager';
              // Force browser to start loading by resetting src
              const src = img.src;
              img.src = '';
              img.src = src;
            }
          }
        });
      }
      
      // Method 1: Preload when slideshow becomes visible (Intersection Observer)
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            preloadRemainingImages();
            observer.disconnect();
          }
        });
      }, {
        rootMargin: '100px' // Start preloading 100px before slideshow is visible
      });
      observer.observe(container);
      
      // Method 2: Preload on interaction (hover/touch)
      const interactionTargets = [
        ...Array.from(container.querySelectorAll('.title-arrow')),
        container.querySelector('.slideshow-container')
      ].filter(Boolean);
      
      interactionTargets.forEach(target => {
        // Desktop: hover
        target!.addEventListener('mouseenter', () => {
          preloadRemainingImages();
        }, { once: true });
        
        // Mobile: touch
        target!.addEventListener('touchstart', () => {
          preloadRemainingImages();
        }, { once: true, passive: true });
      });
      
      function showSlide(index: number) {
        // Preserve scroll position more reliably
        const currentScroll = window.pageYOffset || document.documentElement.scrollTop;
        
        // Prevent any automatic scrolling
        document.body.style.overflowAnchor = 'none';
        
        // Hide all slides and titles
        slides.forEach(slide => {
          slide.classList.add('hidden');
          slide.classList.remove('active');
        });
        specificTitles.forEach(title => {
          title.classList.add('hidden');
          title.classList.remove('block');
        });
        
        // Show current slide and title
        if (slides[index]) {
          slides[index].classList.remove('hidden');
          slides[index].classList.add('active');
        }
        if (specificTitles[index]) {
          specificTitles[index].classList.remove('hidden');
          specificTitles[index].classList.add('block');
        }
        
        // Use requestAnimationFrame to ensure DOM is updated before restoring scroll
        requestAnimationFrame(() => {
          window.scrollTo(0, currentScroll);
          // Re-enable scroll anchoring after a brief delay
          setTimeout(() => {
            document.body.style.overflowAnchor = 'auto';
          }, 100);
        });
      }
      
      function nextSlide() {
        if (isTransitioning) return;
        isTransitioning = true;
        
        // Trigger preload on first interaction
        preloadRemainingImages();
        
        // Prevent focus changes from causing scroll jumps
        const activeElement = document.activeElement as HTMLElement;
        currentSlide = (currentSlide + 1) % slides.length;
        showSlide(currentSlide);
        // Keep focus on the same element to prevent scroll jumps
        if (activeElement) {
          activeElement.blur();
        }
        
        setTimeout(() => {
          isTransitioning = false;
        }, 300);
      }
      
      function prevSlide() {
        if (isTransitioning) return;
        isTransitioning = true;
        
        // Trigger preload on first interaction
        preloadRemainingImages();
        
        // Prevent focus changes from causing scroll jumps
        const activeElement = document.activeElement as HTMLElement;
        currentSlide = (currentSlide - 1 + slides.length) % slides.length;
        showSlide(currentSlide);
        // Keep focus on the same element to prevent scroll jumps
        if (activeElement) {
          activeElement.blur();
        }
        
        setTimeout(() => {
          isTransitioning = false;
        }, 300);
      }
      
      // Touch/Swipe support variables
      let startX = 0;
      let startY = 0;
      let endX = 0;
      let endY = 0;
      const minSwipeDistance = 50;
      
      // Handle swipe gestures
      function handleSwipe() {
        try {
          const deltaX = endX - startX;
          const deltaY = endY - startY;
          
          // Check if horizontal swipe is dominant and meets minimum distance
          if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
            if (deltaX > 0) {
              // Swipe right -> previous slide
              prevSlide();
            } else {
              // Swipe left -> next slide
              nextSlide();
            }
          }
        } catch (error) {
          console.error('Swipe handling error:', error);
        }
      }

      // Add click handlers for navigation buttons (arrows next to title)
      const navButtons = container.querySelectorAll('.slide-nav-left, .slide-nav-right');
      navButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          try {
            e.stopPropagation(); // Prevent triggering image-half click
            const direction = btn.getAttribute('data-direction');
            if (direction === 'next') {
              nextSlide();
            } else if (direction === 'prev') {
              prevSlide();
            }
          } catch (error) {
            console.error('Button click error:', error);
          }
        });
        
        // Keyboard navigation for buttons
        btn.addEventListener('keydown', (e) => {
          try {
            const keyboardEvent = e as KeyboardEvent;
            if (keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ') {
              e.preventDefault();
              e.stopPropagation();
              const direction = btn.getAttribute('data-direction');
              if (direction === 'next') {
                nextSlide();
              } else if (direction === 'prev') {
                prevSlide();
              }
            }
          } catch (error) {
            console.error('Button keyboard error:', error);
          }
        });
      });
      
      // Add image-half click handlers
      const imageContainers = container.querySelectorAll('.image-container');
      imageContainers.forEach(imgContainer => {
        imgContainer.addEventListener('click', (e) => {
          try {
            const mouseEvent = e as MouseEvent;
            
            const rect = (imgContainer as HTMLElement).getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            
            if (mouseEvent.clientX < midpoint) {
              prevSlide();
            } else {
              nextSlide();
            }
          } catch (error) {
            console.error('Image click error:', error);
          }
        });
        
        // Touch handlers for swipe on image
        imgContainer.addEventListener('touchstart', (e) => {
          try {
            const touchEvent = e as TouchEvent;
            startX = touchEvent.touches[0].clientX;
            startY = touchEvent.touches[0].clientY;
          } catch (error) {
            console.error('Touch start error:', error);
          }
        }, { passive: true });
        
        imgContainer.addEventListener('touchend', (e) => {
          try {
            const touchEvent = e as TouchEvent;
            endX = touchEvent.changedTouches[0].clientX;
            endY = touchEvent.changedTouches[0].clientY;
            handleSwipe();
          } catch (error) {
            console.error('Touch end error:', error);
          }
        }, { passive: true });
      });
      
      // Global keyboard navigation
      document.addEventListener('keydown', (e) => {
        try {
          const keyboardEvent = e as KeyboardEvent;
          if (keyboardEvent.key === 'ArrowLeft') {
            prevSlide();
          } else if (keyboardEvent.key === 'ArrowRight') {
            nextSlide();
          }
        } catch (error) {
          console.error('Keyboard navigation error:', error);
        }
      });
      
      // Mark as initialized
      container.setAttribute('data-slideshow-initialized', 'true');
    });
  }
  
  // Robust initialization function that handles multiple scenarios
  function safeInitSlideshows() {
    // Try immediate initialization
    initSlideshows();
    
    // Also try after images are loaded
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initSlideshows);
    }
    
    // And after window load (all resources including images)
    if (document.readyState !== 'complete') {
      window.addEventListener('load', initSlideshows);
    }
    
    // Preserve scroll position on load
    const scrollY = window.scrollY;
    setTimeout(() => {
      window.scrollTo(0, scrollY);
    }, 0);
  }

  // Initialize based on current document state
  if (document.readyState === 'loading') {
    // Document is still loading
    document.addEventListener('DOMContentLoaded', safeInitSlideshows);
  } else {
    // Document is already loaded
    safeInitSlideshows();
  }
  
  // Re-initialize on view transitions (Astro navigation)
  document.addEventListener('astro:after-swap', () => {
    // Clear any existing initialization markers
    document.querySelectorAll('[data-slideshow-initialized]').forEach(el => {
      el.removeAttribute('data-slideshow-initialized');
    });
    
    // Preserve scroll position on navigation
    const scrollY = window.scrollY;
    safeInitSlideshows();
    setTimeout(() => {
      window.scrollTo(0, scrollY);
    }, 0);
  });
  
  // Also listen for astro:page-load (triggered on direct page loads)
  document.addEventListener('astro:page-load', () => {
    safeInitSlideshows();
  });
</script>

<style>
  .slide {
    position: relative;
  }
  
  .specific-title {
    transition: opacity 0.2s ease-in-out;
  }
  
  .slideshow-container {
    overflow: hidden;
  }
  
  .image-container {
    position: relative;
  }
  
  /* Navigation arrow buttons next to title */
  .title-arrow {
    background: none;
    border: none;
    font-size: 1rem;
    line-height: 1;
    color: rgb(107, 114, 128); /* text-gray-500 */
    cursor: pointer;
    padding: 0.25rem;
    transition: color 0.2s ease-in-out;
    user-select: none;
  }
  
  .title-arrow:hover {
    color: var(--foreground);
  }
  
  .title-arrow:focus {
    outline: 2px solid #4a90e2;
    outline-offset: 2px;
    border-radius: 2px;
  }
  
  .title-arrow:focus:not(:focus-visible) {
    outline: none;
  }
  
  /* Hide arrows for single-slide series */
  .work-series[data-slide-count="1"] .title-arrow {
    display: none;
  }
  
  /* Prevent horizontal scroll on mobile */
  @media (max-width: 768px) {
    body {
      overflow-x: hidden;
    }
    
    .work-series {
      overflow: hidden;
    }
  }
  
  /* Prevent scroll jumping during slide transitions */
  .work-series {
    overflow-anchor: none;
  }
  
  .work-series .slide {
    overflow-anchor: none;
  }
  
  .work-series .slideshow-container {
    overflow-anchor: none;
  }
</style>
